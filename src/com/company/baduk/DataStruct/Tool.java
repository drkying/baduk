package com.company.baduk.DataStruct;

import com.company.baduk.Client.ChessPad;
import com.company.baduk.Client.Point;

import java.io.*;

public class Tool {
    //判断IP是否合法
    public static boolean ipCheck(String text) {
        if (text.equals("localhost"))
            return true;
        if (text != null && !text.isEmpty()) {
            // 定义正则表达式
            String regex = "^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\." +
                    "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\." +
                    "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\." +
                    "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$";
            // 判断ip地址是否与正则表达式匹配
            if (text.matches(regex)) {
                // 返回判断信息
                return true;
            } else {
                // 返回判断信息
                return false;
            }
        }
        return false;
    }

    public static int encode(String roomName) {
        int s = 0;
        for (int i = 0; i < roomName.length(); i++) {
            s += (int) roomName.charAt(i);
        }
        return s;
    }

    public static String sumHashCode(Point[][] points) {
        int hash = 0;
        for (int i = 2; i <= 20; i++) {
            for (int j = 2; j <= 20; j++) {
                Point point = points[i][j];
                if (point.getPlayer().equals(Player.BLACK))
                    hash += (point.getX() * 3 + point.getY() * 5) * 3;
                else if (point.getPlayer().equals(Player.WHITE))
                    hash += (point.getX() * 3 + point.getY() * 5) * 5;
                else if (point.getPlayer().equals(Player.NONE))
                    hash--;
            }
        }
        return String.valueOf(hash);
    }

    public static <T extends Serializable> T clone(T obj) {
        T cloneObj = null;
        try {
            // 写入字节流
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ObjectOutputStream obs = new ObjectOutputStream(out);
            obs.writeObject(obj);
            obs.close();

            // 分配内存，写入原始对象，生成新对象
            ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(ios);
            // 返回生成的新对象
            cloneObj = (T) ois.readObject();
            ois.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return cloneObj;
    }
}
